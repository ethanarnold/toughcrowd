# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

**Repository**: `toughcrowd` (GitHub repo already initialized with initial commit)

## Project Overview

toughcrowd is an AI-powered real-time presentation practice tool. Users upload slides (PDF), practice their presentation via microphone, and receive contextual questions generated by Claude based on their speech and slide content.

## Commands

All commands run from the `app/` directory:

```bash
npm run dev              # Start dev server
npm run build            # TypeScript check + Vite build
npm run lint             # ESLint check
npm run format           # Prettier format
npm run format:check     # Prettier check (no write)
npm test                 # Run all tests
npm run test:watch       # Watch mode
npm run test:coverage    # Coverage report (80% minimum enforced)
```

## Architecture

Four-component system:

1. **Slide Processor** - PDF text extraction, visual descriptions, indexed by slide number
2. **Transcript Engine** - Real-time speech-to-text with 60s rolling buffer + cumulative transcript
3. **Question Generator** - Periodic LLM calls (every 10-15s) combining slide context + transcript + history
4. **Session Manager** - Orchestrates pipeline, handles delivery timing, tracks responses

### Code Organization

```
app/src/
├── components/     # React components
├── hooks/          # Custom React hooks
├── services/       # API/business logic
├── stores/         # Zustand state stores
├── types/          # TypeScript interfaces with type guards
├── utils/          # Utility functions
└── test/           # Test setup and MSW mocks
```

### Key Design Patterns

- **Three delivery modes**: Interrupt (real-time), Queue (end of section), Hybrid (urgent interrupts only)
- **Persona system**: skeptical methodologist, senior domain expert, confused-but-engaged, adversarial devil's advocate
- **Question taxonomy**: Clarification, Technical, Conceptual, Methodology, Adversarial, Big Picture
- **Speech-to-text**: Web Speech API for MVP, upgrade path to Deepgram/Whisper

## Development Guidelines

- **Environment variables**: Use `VITE_` prefix for client-side vars (see `app/.env.example`)
- **Type guards**: Use existing type guards in `src/types/index.ts` (e.g., `isSlide()`, `isQuestion()`)
- **PR workflow**: Use GitHub pull requests for all changes. Create feature branches, open PRs for review, and merge to main
- **Checklist updates**: After a PR is merged, update `docs/IMPLEMENTATION_CHECKLIST.md` to mark completed items as done

## Testing & TDD

**Strict Red-Green-Refactor workflow:**
- Never write implementation without a failing test first
- One test at a time: Write ONE failing test, write minimal code to pass it, refactor. Repeat
- Never rewrite a failing test to make it pass — fix the implementation instead

**Test design principles:**
- Test behavior through public interfaces, not implementation details. Tests describe WHAT, not HOW
- Avoid over-mocking. If a test mocks the database, API client, auth, and filesystem, it tests nothing
- Use AAA pattern (Arrange-Act-Assert) or Given-When-Then
- Test names describe behavior: `should_reject_expired_token` not `test_token_3`

**Coverage requirements:**
- Target: 80% (enforced by vitest thresholds). Don't chase 100% with meaningless assertions
- Prioritize coverage for: auth, payments/billing, data integrity, core business logic

**When modifying code:**
- When modifying existing functions, ensure a test exists first. Create one if it doesn't, then modify

## TDD Session Reminder

When asked to implement a feature, always respond by writing a failing test first. Do not write implementation code until the test exists and fails

## Code Style

Enforced by ESLint + Prettier:
- No semicolons
- Single quotes
- 2-space indentation
- 100 character line width

## Development Phases

Current status tracked in `docs/IMPLEMENTATION_CHECKLIST.md`:
- Phase 0 (Complete): Project setup, testing infrastructure, type definitions
- Phase 1 (Complete): PDF upload, slide viewer, session store
- Phase 2: Transcript pipeline, speech-to-text
- Phase 3: Question generation loop, LLM integration
- Phase 4: Interactive Q&A UI, delivery modes, persona system
- Phase 5: Session summary, export features
